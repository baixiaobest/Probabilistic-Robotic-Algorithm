import numpy as np
import scipy.optimize as opt

class PathOptimizer:
    """
    obstacle_map: Object containing obstacle information, used to check distance to obstacle.
    d_max: Distance to obstacle beyond which obstacle potential becomes zero.
    alpha: Constant that define how fast the obstacle potential decays. It decays slower when alpha is bigger.
    k_max: Maximum curvature.
    weights: Weights for obstacle potential, curvature penalty and smoothness objective.
    max_iter: Maximum number of iterations during optimization.
    """
    def __init__(self, obstacle_map, d_max, alpha, k_max, weights, max_iter=1000):
        self.obstacle_map = obstacle_map
        self.d_max = d_max
        self.alpha = alpha
        self.k_max = k_max
        self.weights = weights
        self.max_iter = max_iter

    """
    points: Points to be optimized. These are generated by the A star algorithm.
    """
    def optimize_path(self, points):
        if len(points) == 0:
            return points
        x0 = self._serialize_points(points)
        results = opt.minimize(self._objective_function, x0, method="CG",
                               options={'maxiter': self.max_iter, 'disp': True})
        return self._deserialize_points(results.x)

    def _serialize_points(self, points):
        serialized_points = []
        for point in points:
            serialized_points.append(point[0])
            serialized_points.append(point[1])
        return np.array(serialized_points)

    def _deserialize_points(self, serialized_points):
        points = []
        length = serialized_points.shape[0]
        for i in range(0, length, 2):
            points.append(np.array([serialized_points[i], serialized_points[i + 1]]))
        return points

    def _objective_function(self, serialized_points):
        points = self._deserialize_points(serialized_points)
        cost = self._obstacle_potential(points) + self._curvature_smoothness_penalty(points)
        return cost

    def _obstacle_potential(self, points):
        total_potential = 0
        for point in points:
            distance = self.obstacle_map.distance_to_nearest_obstacle(point)
            # point that is far away from the obstacle is ignored.
            if distance > self.d_max:
                continue
            potential = self.alpha / (self.alpha + distance) * (distance - self.d_max) ** 2 / (self.d_max ** 2)
            total_potential += potential
        return self.weights[0] * total_potential


    def _curvature_smoothness_penalty(self, points):
        # Need at least 3 points to calculate curvature.
        if len(points) < 3:
            return 0

        curvature_penalty = 0
        smoothness_penalty = 0

        for i in range(1, len(points) - 1):
            prev_point = points[i-1]
            curr_point = points[i]
            next_point = points[i+1]

            vec_prev_curr = curr_point - prev_point
            vec_curr_next = next_point - curr_point
            dot_norm = vec_prev_curr @ vec_curr_next / (np.linalg.norm(vec_prev_curr) * np.linalg.norm(vec_curr_next))
            dot_norm = np.clip(dot_norm, -1.0, 1.0)
            angle_diff = np.arccos(dot_norm)
            angle_diff = np.fabs(angle_diff)

            curvature_penalty += (angle_diff / np.linalg.norm(vec_prev_curr) - self.k_max) ** 2
            smoothness_penalty += np.linalg.norm(vec_curr_next - vec_prev_curr) ** 2

        return self.weights[1] * curvature_penalty + self.weights[2] * smoothness_penalty



